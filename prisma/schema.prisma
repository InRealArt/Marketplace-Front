generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["multiSchema"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  schemas  = ["auth", "marketplace", "public"]
}

model Artist {
  id              Int              @id @default(autoincrement())
  name            String
  surname         String
  pseudo          String           @unique
  description     String           @unique
  publicKey       String           @unique
  imageUrl        String           @unique
  isGallery       Boolean          @default(false)
  backgroundImage String?
  artworkStyle    String?
  BackofficeUser  BackofficeUser[]
  collections     Collection[]
  NftCollection   NftCollection[]
  Profile         Profile[]

  @@schema("public")
}

model Collection {
  id              Int              @id @default(autoincrement())
  symbol          String           @unique
  addressAdmin    String
  artistId        Int
  contractAddress String?          @unique
  transactionHash String?
  status          collectionstatus @default(pending)
  name            String?
  smartContractId Int?
  artist          Artist           @relation(fields: [artistId], references: [id])
  nfts            ResourceNft[]

  @@index([smartContractId])
  @@schema("public")
}

model ResourceNft {
  id              Int                 @id @default(autoincrement())
  tokenId         Int?
  tokenUri        String?             @unique
  status          ResourceNftStatuses
  type            ResourceTypes
  minter          String
  collectionId    Int
  name            String              @unique
  imageUri        String?
  description     String
  certificateUri  String?             @unique
  itemId          Int?                @unique
  mockups         String[]
  owner           String?
  transactionHash String?
  tags            String[]
  purchasedOnce   Boolean?            @default(false)
  previousOwner   String?
  Order_old       Order_old[]
  collection      Collection          @relation(fields: [collectionId], references: [id])

  @@schema("public")
}

model Profile {
  id         BigInt     @default(autoincrement())
  created_at DateTime   @default(now()) @db.Timestamptz(6)
  artistId   Int?
  userRole   UserRoles? @default(SELLER)
  userId     String     @id @db.Uuid
  Artist     Artist?    @relation(fields: [artistId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  users      users      @relation(fields: [userId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  @@schema("public")
}

model audit_log_entries {
  instance_id String?   @db.Uuid
  id          String    @id @db.Uuid
  payload     Json?     @db.Json
  created_at  DateTime? @db.Timestamptz(6)
  ip_address  String    @default("") @db.VarChar(64)

  @@index([instance_id], map: "audit_logs_instance_id_idx")
  @@schema("auth")
}

model flow_state {
  id                     String                @id @db.Uuid
  user_id                String?               @db.Uuid
  auth_code              String
  code_challenge_method  code_challenge_method
  code_challenge         String
  provider_type          String
  provider_access_token  String?
  provider_refresh_token String?
  created_at             DateTime?             @db.Timestamptz(6)
  updated_at             DateTime?             @db.Timestamptz(6)
  authentication_method  String
  auth_code_issued_at    DateTime?             @db.Timestamptz(6)
  saml_relay_states      saml_relay_states[]

  @@index([created_at(sort: Desc)])
  @@index([auth_code], map: "idx_auth_code")
  @@index([user_id, authentication_method], map: "idx_user_id_auth_method")
  @@schema("auth")
}

model identities {
  provider_id     String
  user_id         String    @db.Uuid
  identity_data   Json
  provider        String
  last_sign_in_at DateTime? @db.Timestamptz(6)
  created_at      DateTime? @db.Timestamptz(6)
  updated_at      DateTime? @db.Timestamptz(6)
  email           String?   @default(dbgenerated("lower((identity_data ->> 'email'::text))"))
  id              String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  users           users     @relation(fields: [user_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@unique([provider_id, provider], map: "identities_provider_id_provider_unique")
  @@index([email])
  @@index([user_id])
  @@schema("auth")
}

model instances {
  id              String    @id @db.Uuid
  uuid            String?   @db.Uuid
  raw_base_config String?
  created_at      DateTime? @db.Timestamptz(6)
  updated_at      DateTime? @db.Timestamptz(6)

  @@schema("auth")
}

model mfa_amr_claims {
  session_id            String   @db.Uuid
  created_at            DateTime @db.Timestamptz(6)
  updated_at            DateTime @db.Timestamptz(6)
  authentication_method String
  id                    String   @id(map: "amr_id_pk") @db.Uuid
  sessions              sessions @relation(fields: [session_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@unique([session_id, authentication_method], map: "mfa_amr_claims_session_id_authentication_method_pkey")
  @@schema("auth")
}

model mfa_challenges {
  id                     String      @id @db.Uuid
  factor_id              String      @db.Uuid
  created_at             DateTime    @db.Timestamptz(6)
  verified_at            DateTime?   @db.Timestamptz(6)
  ip_address             String      @db.Inet
  otp_code               String?
  web_authn_session_data Json?
  mfa_factors            mfa_factors @relation(fields: [factor_id], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "mfa_challenges_auth_factor_id_fkey")

  @@index([created_at(sort: Desc)], map: "mfa_challenge_created_at_idx")
  @@schema("auth")
}

model mfa_factors {
  id                   String           @id @db.Uuid
  user_id              String           @db.Uuid
  friendly_name        String?
  factor_type          factor_type
  status               factor_status
  created_at           DateTime         @db.Timestamptz(6)
  updated_at           DateTime         @db.Timestamptz(6)
  secret               String?
  phone                String?
  last_challenged_at   DateTime?        @unique @db.Timestamptz(6)
  web_authn_credential Json?
  web_authn_aaguid     String?          @db.Uuid
  mfa_challenges       mfa_challenges[]
  users                users            @relation(fields: [user_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@unique([user_id, phone], map: "unique_phone_factor_per_user")
  @@index([user_id, created_at], map: "factor_id_created_at_idx")
  @@index([user_id])
  @@schema("auth")
}

model one_time_tokens {
  id         String              @id @db.Uuid
  user_id    String              @db.Uuid
  token_type one_time_token_type
  token_hash String
  relates_to String
  created_at DateTime            @default(now()) @db.Timestamp(6)
  updated_at DateTime            @default(now()) @db.Timestamp(6)
  users      users               @relation(fields: [user_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@unique([user_id, token_type])
  @@index([relates_to], map: "one_time_tokens_relates_to_hash_idx", type: Hash)
  @@index([token_hash], map: "one_time_tokens_token_hash_hash_idx", type: Hash)
  @@schema("auth")
}

model refresh_tokens {
  instance_id String?   @db.Uuid
  id          BigInt    @id @default(autoincrement())
  token       String?   @unique(map: "refresh_tokens_token_unique") @db.VarChar(255)
  user_id     String?   @db.VarChar(255)
  revoked     Boolean?
  created_at  DateTime? @db.Timestamptz(6)
  updated_at  DateTime? @db.Timestamptz(6)
  parent      String?   @db.VarChar(255)
  session_id  String?   @db.Uuid
  sessions    sessions? @relation(fields: [session_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@index([instance_id])
  @@index([instance_id, user_id])
  @@index([parent])
  @@index([session_id, revoked])
  @@index([updated_at(sort: Desc)])
  @@schema("auth")
}

model saml_providers {
  id                String        @id @db.Uuid
  sso_provider_id   String        @db.Uuid
  entity_id         String        @unique
  metadata_xml      String
  metadata_url      String?
  attribute_mapping Json?
  created_at        DateTime?     @db.Timestamptz(6)
  updated_at        DateTime?     @db.Timestamptz(6)
  name_id_format    String?
  sso_providers     sso_providers @relation(fields: [sso_provider_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@index([sso_provider_id])
  @@schema("auth")
}

model saml_relay_states {
  id              String        @id @db.Uuid
  sso_provider_id String        @db.Uuid
  request_id      String
  for_email       String?
  redirect_to     String?
  created_at      DateTime?     @db.Timestamptz(6)
  updated_at      DateTime?     @db.Timestamptz(6)
  flow_state_id   String?       @db.Uuid
  flow_state      flow_state?   @relation(fields: [flow_state_id], references: [id], onDelete: Cascade, onUpdate: NoAction)
  sso_providers   sso_providers @relation(fields: [sso_provider_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@index([created_at(sort: Desc)])
  @@index([for_email])
  @@index([sso_provider_id])
  @@schema("auth")
}

model schema_migrations {
  version String @id @db.VarChar(255)

  @@schema("auth")
}

model sessions {
  id             String           @id @db.Uuid
  user_id        String           @db.Uuid
  created_at     DateTime?        @db.Timestamptz(6)
  updated_at     DateTime?        @db.Timestamptz(6)
  factor_id      String?          @db.Uuid
  aal            aal_level?
  not_after      DateTime?        @db.Timestamptz(6)
  refreshed_at   DateTime?        @db.Timestamp(6)
  user_agent     String?
  ip             String?          @db.Inet
  tag            String?
  mfa_amr_claims mfa_amr_claims[]
  refresh_tokens refresh_tokens[]
  users          users            @relation(fields: [user_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@index([not_after(sort: Desc)])
  @@index([user_id])
  @@index([user_id, created_at], map: "user_id_created_at_idx")
  @@schema("auth")
}

/// This model contains an expression index which requires additional setup for migrations. Visit https://pris.ly/d/expression-indexes for more info.
model sso_domains {
  id              String        @id @db.Uuid
  sso_provider_id String        @db.Uuid
  domain          String
  created_at      DateTime?     @db.Timestamptz(6)
  updated_at      DateTime?     @db.Timestamptz(6)
  sso_providers   sso_providers @relation(fields: [sso_provider_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@index([sso_provider_id])
  @@schema("auth")
}

/// This model contains an expression index which requires additional setup for migrations. Visit https://pris.ly/d/expression-indexes for more info.
model sso_providers {
  id                String              @id @db.Uuid
  resource_id       String?
  created_at        DateTime?           @db.Timestamptz(6)
  updated_at        DateTime?           @db.Timestamptz(6)
  saml_providers    saml_providers[]
  saml_relay_states saml_relay_states[]
  sso_domains       sso_domains[]

  @@schema("auth")
}

/// This model contains an expression index which requires additional setup for migrations. Visit https://pris.ly/d/expression-indexes for more info.
model users {
  instance_id                 String?           @db.Uuid
  id                          String            @id @db.Uuid
  aud                         String?           @db.VarChar(255)
  role                        String?           @db.VarChar(255)
  email                       String?           @db.VarChar(255)
  encrypted_password          String?           @db.VarChar(255)
  email_confirmed_at          DateTime?         @db.Timestamptz(6)
  invited_at                  DateTime?         @db.Timestamptz(6)
  confirmation_token          String?           @db.VarChar(255)
  confirmation_sent_at        DateTime?         @db.Timestamptz(6)
  recovery_token              String?           @db.VarChar(255)
  recovery_sent_at            DateTime?         @db.Timestamptz(6)
  email_change_token_new      String?           @db.VarChar(255)
  email_change                String?           @db.VarChar(255)
  email_change_sent_at        DateTime?         @db.Timestamptz(6)
  last_sign_in_at             DateTime?         @db.Timestamptz(6)
  raw_app_meta_data           Json?
  raw_user_meta_data          Json?
  is_super_admin              Boolean?
  created_at                  DateTime?         @db.Timestamptz(6)
  updated_at                  DateTime?         @db.Timestamptz(6)
  phone                       String?           @unique
  phone_confirmed_at          DateTime?         @db.Timestamptz(6)
  phone_change                String?           @default("")
  phone_change_token          String?           @default("") @db.VarChar(255)
  phone_change_sent_at        DateTime?         @db.Timestamptz(6)
  confirmed_at                DateTime?         @default(dbgenerated("LEAST(email_confirmed_at, phone_confirmed_at)")) @db.Timestamptz(6)
  email_change_token_current  String?           @default("") @db.VarChar(255)
  email_change_confirm_status Int?              @default(0) @db.SmallInt
  banned_until                DateTime?         @db.Timestamptz(6)
  reauthentication_token      String?           @default("") @db.VarChar(255)
  reauthentication_sent_at    DateTime?         @db.Timestamptz(6)
  is_sso_user                 Boolean           @default(false)
  deleted_at                  DateTime?         @db.Timestamptz(6)
  is_anonymous                Boolean           @default(false)
  identities                  identities[]
  mfa_factors                 mfa_factors[]
  one_time_tokens             one_time_tokens[]
  sessions                    sessions[]
  Order_old                   Order_old[]
  Profile                     Profile?
  Wallet                      Wallet[]

  @@index([instance_id])
  @@index([is_anonymous])
  @@schema("auth")
}

model Transaction {
  id              Int       @id @default(autoincrement())
  tokenId         Int?
  functionName    String?
  transactionHash String?   @unique(map: "Transaction_txHash_key")
  from            String
  to              String
  created_at      DateTime? @default(now()) @db.Timestamptz(6)
  price           Decimal?  @db.Decimal
  transferFrom    String?
  transferTo      String?
  contractAddress String?

  @@schema("public")
}

model User {
  id            String              @id(map: "user_pkey") @db.VarChar(255)
  name          String              @db.VarChar(255)
  email         String              @unique(map: "user_email_key") @db.VarChar(255)
  emailVerified Boolean
  image         String?             @db.VarChar(255)
  createdAt     DateTime            @db.Timestamp(6)
  updatedAt     DateTime            @db.Timestamp(6)
  accounts      Account[]
  sessions      Session[]
  Order         marketplace_Order[]
  Address       Address[]

  @@map("User")
  @@schema("auth")
}

model Session {
  id        String   @id(map: "session_pkey") @db.VarChar(255)
  expiresAt DateTime @db.Timestamp(6)
  token     String   @unique(map: "session_token_key") @db.VarChar(255)
  createdAt DateTime @db.Timestamp(6)
  updatedAt DateTime @db.Timestamp(6)
  ipAddress String?  @db.VarChar(255)
  userAgent String?  @db.VarChar(255)
  userId    String   @db.VarChar(255)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "session_userId_fkey")

  @@index([userId], map: "session_userId_idx")
  @@map("Session")
  @@schema("auth")
}

model Account {
  id                    String    @id(map: "account_pkey") @db.VarChar(255)
  accountId             String    @db.VarChar(255)
  providerId            String    @db.VarChar(255)
  userId                String    @db.VarChar(255)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime? @db.Timestamp(6)
  refreshTokenExpiresAt DateTime? @db.Timestamp(6)
  scope                 String?   @db.VarChar(255)
  password              String?   @db.VarChar(255)
  createdAt             DateTime  @db.Timestamp(6)
  updatedAt             DateTime  @db.Timestamp(6)
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "account_userId_fkey")

  @@index([userId], map: "account_userId_idx")
  @@map("Account")
  @@schema("auth")
}

model Verification {
  id         String    @id(map: "verification_pkey") @db.VarChar(255)
  identifier String    @db.VarChar(255)
  value      String    @db.VarChar(255)
  expiresAt  DateTime  @db.Timestamp(6)
  createdAt  DateTime? @db.Timestamp(6)
  updatedAt  DateTime? @db.Timestamp(6)

  @@index([identifier, value], map: "verification_identifier_value_idx")
  @@map("Verification")
  @@schema("auth")
}

model AuthCertificate {
  id             Int           @id @default(autoincrement())
  nftItemId      Int?          @unique
  nftItem        NftItem?      @relation(fields: [nftItemId], references: [id], onDelete: Cascade)
  physicalItemId Int?          @unique
  physicalItem   PhysicalItem? @relation(fields: [physicalItemId], references: [id], onDelete: Cascade)
  file           Bytes

  @@index([nftItemId])
  @@index([physicalItemId])
  @@schema("public")
}

/// This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
model BackofficeUser {
  id               Int                  @id(map: "shopifyUser_pkey") @default(autoincrement())
  email            String?              @unique(map: "shopifyUser_email_key")
  walletAddress    String
  lastLogin        DateTime             @db.Timestamp(6)
  userMetadata     Json
  role             BackofficeUserRoles?
  createdAt        DateTime             @default(now()) @db.Timestamp(6)
  isShopifyGranted Boolean              @default(false)
  lastName         String?
  firstName        String?
  linkedWallets    Json                 @default("[]")
  artistId         Int?
  Artist           Artist?              @relation(fields: [artistId], references: [id])
  Item             Item[]
  Address          Address[]

  @@index([artistId])
  @@index([email], map: "shopifyUser_email_idx")
  @@index([walletAddress], map: "shopifyUser_walletAddress_idx")
  @@schema("public")
}

model Item {
  id                 Int            @id @default(autoincrement())
  name               String
  description        String
  idUser             Int
  user               BackofficeUser @relation(fields: [idUser], references: [id])
  tags               String[]       @default([])
  slug               String?        @unique
  metaDescription    String
  metaTitle          String
  mainImageUrl       String?
  secondaryImagesUrl String[]       @default([])
  realViewCount      Int            @default(0)
  fakeViewCount      Int            @default(0)

  mediumId    Int?
  medium      ArtworkMedium?    @relation(fields: [mediumId], references: [id])
  styleId     Int?
  style       ArtworkStyle?     @relation(fields: [styleId], references: [id])
  techniqueId Int?
  technique   ArtworkTechnique? @relation(fields: [techniqueId], references: [id])

  // Relations
  nftItem        NftItem?
  physicalItem   PhysicalItem?
  ItemCategory   ItemCategory? @relation(fields: [itemCategoryId], references: [id])
  itemCategoryId Int?

  @@index([idUser])
  @@index([mediumId])
  @@index([styleId])
  @@index([techniqueId])
  @@schema("public")
}

model ItemCategory {
  id           Int            @id @default(autoincrement())
  name         String
  Item         Item[]
  PhysicalItem PhysicalItem[]

  @@schema("public")
}

model NftCollection {
  id              Int               @id @default(autoincrement())
  name            String
  symbol          String
  addressAdmin    String
  artistId        Int
  contractAddress String?
  transactionHash String?
  status          CollectionStatus  @default(pending)
  smartContractId Int?
  Artist          Artist            @relation(fields: [artistId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  NftResource_old NftResource_old[]

  @@unique([symbol, smartContractId])
  @@index([artistId])
  @@index([smartContractId])
  @@schema("public")
}

/// This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
model NftResource {
  id               Int                 @id @default(autoincrement())
  tokenId          Int?
  tokenUri         String?             @unique
  status           NftResourceStatuses
  type             ResourceTypes
  minter           String?
  collectionId     Int
  name             String              @unique
  imageUri         String?
  description      String
  certificateUri   String?             @unique
  blockchainItemId Int?                @unique
  mockups          String[]
  owner            String?
  transactionHash  String?
  tags             String[]
  purchasedOnce    Boolean?            @default(false)
  previousOwner    String?
  NftItem          NftItem[]

  @@schema("public")
}

model Wallet {
  id         Int       @id(map: "wallets_pkey") @default(autoincrement())
  address    String    @unique(map: "wallets_address_key") @db.VarChar(255)
  created_at DateTime? @default(now()) @db.Timestamptz(6)
  updated_at DateTime? @default(now()) @db.Timestamptz(6)
  user_id    String    @db.Uuid
  users      users     @relation(fields: [user_id], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "wallets_user_id_fkey")

  @@index([address], map: "wallets_address_idx")
  @@index([user_id], map: "wallets_user_id_idx")
  @@schema("public")
}

model Cart {
  id         Int       @id(map: "cart_pkey") @default(autoincrement())
  userId     String    @unique(map: "cart_userId_key")
  items      Json
  createdAt  DateTime? @default(now()) @db.Timestamptz(6)
  updatedAt  DateTime? @updatedAt @db.Timestamptz(6)
  totalPrice Decimal   @default(0) @db.Decimal(10, 2)

  @@schema("marketplace")
}

model AnonymousCart {
  cartId    String   @id
  items     Json
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  expiresAt DateTime

  @@schema("marketplace")
}

model Invoice {
  id                      Int           @id @default(autoincrement())
  invoiceNumber           String        @unique
  createdAt               DateTime      @default(now()) @db.Timestamp(6)
  dueDate                 DateTime?     @db.Timestamp(6)
  orderId                 Int           @unique
  orderNumber             String
  orderDate               DateTime      @db.Timestamp(6)
  subtotalPrice           Decimal       @db.Decimal(10, 2)
  vatAmount               Decimal       @db.Decimal(10, 2)
  totalPrice              Decimal       @db.Decimal(10, 2)
  vatRate                 Decimal       @db.Decimal(5, 2)
  paidAt                  DateTime?     @db.Timestamp(6)
  paymentMethod           String
  isPaid                  Boolean       @default(false)
  sellerName              String
  sellerAddress           String
  sellerVatNumber         String?
  sellerSiret             String
  sellerEmail             String
  customerName            String
  customerEmail           String
  customerId              String
  billingAddressFullname  String
  billingAddressStreet    String
  billingAddressCity      String
  billingAddressPostCode  String
  billingAddressCountry   String
  billingAddressVatNumber String?
  legalMentions           String
  paymentTerms            String
  invoiceType             InvoiceType   @default(INVOICE)
  InvoiceItem             InvoiceItem[]

  @@index([customerId])
  @@index([invoiceNumber])
  @@index([orderNumber])
  @@schema("marketplace")
}

model InvoiceItem {
  id             Int           @id @default(autoincrement())
  invoiceId      Int
  nftItemId      Int?
  physicalItemId Int?
  title          String
  description    String?
  unitPrice      Decimal       @db.Decimal(10, 2)
  vatRate        Decimal       @db.Decimal(5, 2)
  vatAmount      Decimal       @db.Decimal(10, 2)
  totalPrice     Decimal       @db.Decimal(10, 2)
  Invoice        Invoice       @relation(fields: [invoiceId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  NftItem        NftItem?      @relation(fields: [nftItemId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  PhysicalItem   PhysicalItem? @relation(fields: [physicalItemId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  @@index([invoiceId])
  @@index([nftItemId])
  @@index([physicalItemId])
  @@schema("marketplace")
}

model marketplace_Order {
  id                   Int         @id @default(autoincrement())
  orderNumber          String      @unique
  createdAt            DateTime    @default(now()) @db.Timestamp(6)
  subtotalPrice        Decimal     @db.Decimal(10, 2)
  vatAmount            Decimal     @db.Decimal(10, 2)
  totalPrice           Decimal     @db.Decimal(10, 2)
  vatRate              Decimal     @db.Decimal(5, 2)
  invoiceNumber        String?
  paidAt               DateTime?   @db.Timestamp(6)
  paymentMethod        String
  customerId           String
  customerName         String
  customerEmail        String
  billingAddressId     Int
  billingStreetAddress String
  billingPostalCode    String
  billingCity          String
  billingCountry       String
  billingVatNumber     String?
  Address              Address     @relation(fields: [billingAddressId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  User                 User        @relation(fields: [customerId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  OrderItem            OrderItem[]

  @@index([customerId])
  @@index([orderNumber])
  @@map("Order")
  @@schema("marketplace")
}

model OrderItem {
  id             Int               @id @default(autoincrement())
  orderId        Int
  nftItemId      Int?
  physicalItemId Int?
  title          String
  unitPrice      Decimal           @db.Decimal(10, 2)
  vatRate        Decimal           @db.Decimal(5, 2)
  vatAmount      Decimal           @db.Decimal(10, 2)
  totalPrice     Decimal           @db.Decimal(10, 2)
  NftItem        NftItem?          @relation(fields: [nftItemId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  Order          marketplace_Order @relation(fields: [orderId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  PhysicalItem   PhysicalItem?     @relation(fields: [physicalItemId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  @@index([nftItemId])
  @@index([orderId])
  @@index([physicalItemId])
  @@schema("marketplace")
}

model Address {
  id            Int    @id @default(autoincrement())
  name          String //Name for the adddress
  // Champs minimums obligatoires pour facturation valide
  firstName     String
  lastName      String
  streetAddress String
  postalCode    String
  city          String
  country       String // Country name (for VAT rules)
  countryCode   String // Country code (for VAT rules)

  // Numéro TVA pour B2B (obligatoire si client professionnel)
  vatNumber String?

  // Relations Customer (adress d'un client dans la marketplace)
  customer         User?           @relation(fields: [customerId], references: [id])
  customerId       String?
  // Relations BackofficeUser (adress d'un artiste dans le backoffice)
  backofficeUser   BackofficeUser? @relation(fields: [backofficeUserId], references: [id], onDelete: Cascade)
  backofficeUserId Int?

  orders              marketplace_Order[]
  physicalItems       PhysicalItem[]      @relation("PhysicalItemShipping")

  @@map("Address")
  @@schema("public")
}

model ThirdPartyAddress {
  id        String @id
  addressId Int?

  @@index([addressId], map: "idx_thirdpartyaddress_addressId")
  @@schema("public")
}

// model AuthCertificate_old {
//   id     Int   @id(map: "AuthCertificate_pkey") @default(autoincrement())
//   idItem Int
//   file   Bytes

//   @@index([idItem], map: "AuthCertificate_idItem_idx")
//   @@schema("public")
// }

model NftItem {
  id              Int              @id @default(autoincrement())
  itemId          Int              @unique
  item            Item             @relation(fields: [itemId], references: [id], onDelete: Cascade)
  idNftResource   Int?
  nftResource     NftResource?     @relation(fields: [idNftResource], references: [id])
  price           Int              @default(0)
  status          NftItemStatus    @default(created)
  authCertificate AuthCertificate?
  orderItems      OrderItem[]
  invoiceItems    InvoiceItem[]

  @@index([itemId])
  @@index([idNftResource])
  @@schema("public")
}

/// This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
model NftResource_old {
  id               Int                 @id(map: "nftResource_pkey") @default(autoincrement())
  tokenId          Int?
  tokenUri         String?             @unique(map: "nftResource_tokenUri_key")
  status           ResourceNftStatuses
  type             ResourceTypes
  minter           String
  collectionId     Int
  name             String              @unique(map: "nftResource_name_key")
  imageUri         String?
  description      String
  certificateUri   String?             @unique(map: "nftResource_certificateUri_key")
  blockchainItemId Int?                @unique(map: "nftResource_blockchainItemId_key")
  mockups          String[]
  owner            String?
  transactionHash  String?
  tags             String[]
  purchasedOnce    Boolean?            @default(false)
  previousOwner    String?
  NftCollection    NftCollection       @relation(fields: [collectionId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "NftResource_collectionId_fkey")

  @@index([collectionId], map: "nftResource_collectionId_idx")
  @@index([name], map: "nftResource_name_idx")
  @@schema("public")
}

/// This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
model Order_old {
  id          BigInt      @id(map: "Order_pkey") @default(autoincrement())
  created_at  DateTime?   @default(now()) @db.Timestamptz(6)
  nftId       Int
  userId      String      @db.Uuid
  orderStatus OrderStatus @default(WAITING_FOR_CONFIRMATION)
  ResourceNft ResourceNft @relation(fields: [nftId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "Order_nftId_fkey")
  users       users       @relation(fields: [userId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "Order_userId_fkey")

  @@schema("public")
}

model PhysicalItem {
  id                Int                @id @default(autoincrement())
  itemId            Int                @unique
  item              Item               @relation(fields: [itemId], references: [id], onDelete: Cascade)
  price             Int                @default(0)
  status            PhysicalItemStatus @default(created)
  stockQty          Int                @default(0)
  initialQty        Int                @default(1)
  categoryId        Int?
  category          ItemCategory?      @relation(fields: [categoryId], references: [id])
  height            Decimal?           @db.Decimal(10, 2)
  width             Decimal?           @db.Decimal(10, 2)
  weight            Decimal?           @db.Decimal(10, 2)
  unitHeight        String?
  unitWidth         String?
  unitWeight        String?
  creationYear      Int?
  shippingAddressId Int?
  shippingAddress   Address?           @relation("PhysicalItemShipping", fields: [shippingAddressId], references: [id])
  orderItems        OrderItem[]
  invoiceItems      InvoiceItem[]
  authCertificate   AuthCertificate?

  @@index([itemId])
  @@index([categoryId])
  @@index([shippingAddressId])
  @@schema("public")
}

enum ResourceTypes {
  IMAGE
  VIDEO

  @@schema("public")
}

enum Web3Roles {
  MINTER
  ADMIN

  @@schema("public")
}

enum ResourceNftStatuses {
  UPLOADIPFS
  UPLOADCERTIFICATE
  UPLOADMETADATA
  MINED
  LISTED
  SOLD
  ROYALTYSET

  @@schema("public")
}

enum UserRoles {
  SELLER
  PARTNER
  GALLERY
  ADMIN

  @@schema("public")
}

enum aal_level {
  aal1
  aal2
  aal3

  @@schema("auth")
}

enum code_challenge_method {
  s256
  plain

  @@schema("auth")
}

enum factor_status {
  unverified
  verified

  @@schema("auth")
}

enum factor_type {
  totp
  webauthn
  phone

  @@schema("auth")
}

enum one_time_token_type {
  confirmation_token
  reauthentication_token
  recovery_token
  email_change_token_new
  email_change_token_current
  phone_change_token

  @@schema("auth")
}

enum OrderStatus {
  WAITING_FOR_CONFIRMATION
  CONFIRMED
  PROCESS_OF_DELIVERY
  DELIVER

  @@schema("public")
}

enum BackofficeUserRoles {
  admin
  artist
  galleryManager

  @@schema("public")
}

enum Chain {
  eth_mainnet
  sepolia
  polygon_mainnet
  polygon_testnet

  @@schema("public")
}

enum CollectionStatus {
  pending
  confirmed
  failed

  @@schema("public")
}

enum ItemStatus {
  created
  pending
  minted
  listed

  @@schema("public")
}

enum NetworkType {
  mainnet
  sepolia
  polygon
  polygonAmoy
  arbitrum
  base
  sepoliaBase

  @@schema("public")
}

enum NotificationStatus {
  APPROVED
  REJECTED

  @@schema("public")
}

enum NotificationSubject {
  requestShopifyMember

  @@schema("public")
}

enum RequestArtworkStatus {
  pending
  listed

  @@schema("public")
}

enum collectionstatus {
  pending
  confirmed
  failed

  @@schema("public")
}

enum InvoiceType {
  INVOICE
  CREDIT_NOTE
  PROFORMA
  RECEIPT

  @@schema("marketplace")
}

enum NftItemStatus {
  created
  pending
  minted
  listed
  sold

  @@schema("public")
}

enum NftResourceStatuses {
  UPLOADIPFS
  UPLOADCERTIFICATE
  UPLOADMETADATA
  MINED
  ROYALTYSET
  LISTED
  SOLD

  @@schema("public")
}

enum PhysicalItemStatus {
  created
  pending
  listed
  sold

  @@schema("public")
}

model ArtworkMedium {
  id    Int    @id @default(autoincrement())
  name  String
  items Item[]

  @@schema("public")
}

model ArtworkStyle {
  id    Int    @id @default(autoincrement())
  name  String
  items Item[]

  @@schema("public")
}

model ArtworkTechnique {
  id    Int    @id @default(autoincrement())
  name  String
  items Item[]

  @@schema("public")
}
